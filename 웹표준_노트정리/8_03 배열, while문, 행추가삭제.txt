8_3 배열


_______________________________


document.forms
현재 문서의 모든 폼이 *배열로* 다 넘어옴



●배열.(=컬렉션/ 자료구조(map구조,list구조,set구조...) ->반복문에 자주 쓰여용
[i]:배열을 의미하는 기호
자바는 객체지향언어. 따라서 다른 프로그램과 조금 다르게 배열을 인식.

-각 요소의 index는 0부터 시작.
-배열의 길이: length(예약어는 변수명으로 사용 불가능)
	보통 배열의 길이 -1 = 마지막 요소를 의미.
-받은 배열은 무조건 index로 가리켜야 함.


●배열 선언, 생성, 초기화.
let ar1 = new Array(갯수); 		//선언과 생성
ar1[0] = 100; 		  		//초기화 (=값 할당)
let ar1 = ["자바", "스프링", "파이썬"]; 	//선언,생성,초기화


●(버튼을 눌렀을 때) 첫번째 폼의 각 요소들을 '배열'로 받을 때,
onclick="exe(this.form)"
function exe(frm){
	let ar = frm.elements;

대신에
<button type="button" onclick="exe()">
function exe(){
	let ar = document.forms[0].elements;
현재 문서의/ 첫번째 폼의/ 각 요소들을 배열로 주세요.
이렇게 주문해도 됨.


●dataset
속성의 이름을 내 마음대로 적용할 수 있음.
data-데이터셋명="원하는내용" 속성을 부여
ex) <input type="text" id="s_id" data-tag-name="아이디"/>

data- 이후에 있는 이름으로 나중에 이용할 수 있음.
alert(ar[i](해당태그).dataset.tagName + "을(를) 입력하세요.") 이렇게
자바스크립트에서는 -를 사용하지 않으므로 -뒷 알파벳을 대문자로 변화.


●break와 continue
break; : 가장 가까운 반복문에서 탈출!
	->반복문 탈출 시 사용.
continue; : 다음 회차로 건너뛰세용
	->특정 조건에서만 생략하고 싶을 때 if랑 같이 사용하는 듯.


●while문의 구성

let idx = 0
while(조건식){
	수행할 구문들..;
	++idx;
}

예시) 1부터 10까지 반복하는 while문
let i = 1;                         //초기식이 밖에 존재
while(i<=10){
      document.write(i+"<br/>")    // 1만 계속 찍음
      ★i++;★
}
				   //while문을 잘 못 쓰면 무한 반복에 빠짐.


이거 복습하기★★★★★★★★★★★★
●행추가 하기
1. table 받아오기 :
2. tbody 받아오기:
3. td 만들기
4. tr 만들기
5. td 를 tr에 넣기
6. tr을 tbody에 넣기.

0. 인덱스로 사용할 변수는 함수 밖에서 선언하고 함수 안에서 해당 인덱스 값을 증감.

◇let td1 = document.createElement("원하는 요소")
	: 원하는 요소 만들고 그 요소의 변수 이름은 td1

◇원하는요소.appendChild(자식요소); : 원하는 요소안에 자식요소 추가

◇만일 id같이 중복되면 안되는 값을 입력하고 싶다면
	"btn"+idx(증감되는 인덱스 값)

◇tr.onmouseover = function(){
           table.rIdx = this.rowIndex;
		  }
	-onmouseover : 마우스가 올라왔을 때 "이벤트"
	-this.rowIdex : 현재 객체의 행번호.

◇table.deleteRow(5);
	:테이블의 5번째 행을 삭제하세요.
	



◇deleteRow(): 테이블의 내장함수. 테이블의 메소드.
따라서 위 함수를 쓰려면 우선 table.을 부르고 그 안에 있는 deleteRow(행번호)를 실행해주세욥!



●다중반복문
보통 2차원배열과 함께 씀.
바깥의 반복문 = 행단위
안쪽의 반복문 = 열단위
	->가로로 별을 반복해서 찍어내고(안쪽 반복문)
	   그 다음줄에도 찍어내서 행추가(바깥쪽 반복문)



●익명함수 : 한번쓰고 버리는거
예) tr.onmouseover = function(){}
tr이라는 행에 마우스가 올라왔을 때 이 함수를 쓰고 버림.





-----------------------------------------
* * * *

별표찍기!한번 해보쟝


하루에 이론 하나씩 외우는 것도 나쁘지 않을 것 같네!
오늘은 JWT 다!!!


input type txt를 테이블 안에 넣기 => 지원서 같은거 쓸 때 내가 행을 추가한 뒤 자격증 정보 입력하는 것 같은 것들!




질문:

53행
1. 점들 사이에는 변수명만 올 수 있는 건가요?(무엇을 쓸 수 있는지 궁금함)
예를 들어, let tbody = table.children[2];에서
let tbody = t1.tbody;라고 태그아이디를 냅다 질러버리면 안되나요?

.은 객체를 활용하는 애. 

//안됩니다. 객체만 넣을 수 있는데요, 아이디는 객체의 식별요소 중 하나일 뿐이지 객체 자체를 의미할 수 는 없습니다.
따라서 getElementById("t1")이라는 문장을 통해서 t1의 아이디로 테이블태그를 찾은 뒤 그것을 선언한 table에 객체로써 받아내야 비로소 "호명"해서 사용할 수 있음.
굳이굳이 선언해서 객체로 받아내지 않고 싶다면 매번 document.getElmentById("t1")을 적어주면서 사용하도 큰 문제는 없음.



83행
2. 현재 테이블의 행번호를 t_rowIdx에 저장한다는데...

1>저는  table에 t_rowIdx라는 속성을 부여한 적도 없는데욥
	:예, 지금 쓰신 문장이 속성부여입니다. table.rIdx = ~
	위에 이미 btn.type = "button"이라고 써보셨잖아욥.
	btn이라는 객체의 type을 "button"이라고 저장해주세요.를 의미


2>t_rowIdx에 저장했다 치고, 브레이스 안에서 생성된 애들은 브레이스 밖으로 나가면 사라지는 것 아닌가요? 어떻게 얘가 끝까지 살아남아서 그 다음 함수btn.onclick까지 들어가나요?
	:예, 만일 table을 브레이스 안에서 생성했다면 사라지겠죠!
	그러나  t1은 애초부터 생성되어있고,
	더군더나 table은 해당 브레이스 밖에서 선언하셨잖아욥.
	그래서 table은 브레이스 안에서 속성을 지정했다 하더라도
	브레이스 밖에서도 그것을 기억하는 것 뿐!


3> thead부분은 변수 tr을 갖지 않은 행이므로 onmouseover에 감지되지 않는 이유는 알겠다.
그런데 table.deleteRow에서, table은 t1전체이지 않은가?
그렇다면 table은 thead를 포함하는 것이 아닌가?
그렇다면 onmouseover에서 감지된 rowIndex값과  t1테이블의 행 값은 1씩 차이나는 것이 아닌가?
	이 부분은 내가 한참 헷갈렸다. 어젯밤에 좀 많이 힘들었나보다.
	우선. onmouseover자체는 이벤트. 트리거로 인해 발동되는 이벤트.
	이 경우에는, tr.에! nomouseover되면! = function(){이 수행되는 것.
	앞서 내가 말한 것처럼 tr은 추가버튼을 눌러 생성된 행만을 의미하기 때문에,
	onmouseover이라는 이벤트는 추가버튼으로 생성된 행 위에서만 발동할 것.
	따라서 그 외의 행(원초부터 존재하던 행(thead같이))에서는 rIdx에 행번호를 저장하지는 않을것.
	그러나, rowIndex는 javascript에 존재하는  식임. 내가 하고싶은 말은, 내가 tr로
	무슨 행을 얼마나 만들었던, rowIndex는 테이블전체를 기준으로 행의 갯수를 셀 것임.

	따라서 행 값에 차이는 없을 것.

83행
4>삭제버튼 이벤트는 꼭 addRow()함수 안에 들어있어야 하나요? 왜요?
	예 당연하죠... tr이라는 객체를 addRow()에서 만드셨잖아요....
	그리고 tr이라는 애는 꼭 버튼이 눌려야먄 새로 생성된다는 애이기 때문에,
	매커니즘을 생각해보면 절대 addRow()밖에서 만들 수 없는 것;.


83행
5>두 함수(onmouseove와 onclick)의 순서는 달라져도 상관없는건가요?


예. 상관 없습니다. onmouseover과 onclick 은 함수가 아니라 이벤트 입니다.
따라서 특정 상황이 발생할 때 이벤트가 실행되는 것이라고 생각하십쇼.
버튼을 onclick하기 위해서는 버튼이 존재하는 행위로 마우스가 필연적으로 먼저 올라오게 됩니당.
따라서 두 이벤트의 작성 순서가 다르더라도, 무조건 onmouseover 이벤트가 우선 실행되어 테이블에 rIdx라는 속성을 만들어 행번호를 저장하는게 첫번째.
그 다음에 삭제버튼을 누르게 된다면 onclick이벤트가 발생하여 rIdx속성에서 value값을 뽑아내어 사용.